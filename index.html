<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="color-scheme" content="dark"/>
  <title>Degla — Mission Planning, Cursor‑style</title>
  <meta name="description" content="Degla is the Cursor for mission planning. Vibe‑plan a full mission and watch a swarm of drones coordinate through constraints and failures to achieve your objective."/>
  <meta property="og:title" content="Degla — Mission Planning, Cursor‑style"/>
  <meta property="og:description" content="Vibe‑plan a full mission and watch a swarm of drones coordinate through constraints and failures to achieve your objective."/>
  <meta name="theme-color" content="#05070b"/>
  <style>
    :root{
      --bg0:#05070b;
      --bg1:#0b1220;
      --panel: rgba(255,255,255,.06);
      --line: rgba(255,255,255,.10);
      --line2: rgba(255,255,255,.06);
      --text:#e5e7eb;
      --muted:#94a3b8;
      --accent:#7c3aed;
      --accent2:#22c55e;
      --danger:#ef4444;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      --shadow: 0 18px 60px rgba(0,0,0,.45);
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 760px at 15% 18%, rgba(124,58,237,.20), transparent 55%),
        radial-gradient(900px 640px at 82% 70%, rgba(34,197,94,.12), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 55%, var(--bg0));
      overflow-x:hidden;
    }

    .bg{
      position:fixed;
      inset:0;
      z-index:0;
    }
    canvas{ width:100%; height:100%; display:block; }
    .vignette{
      position:absolute;
      inset:-1px;
      background:
        radial-gradient(900px 520px at 50% 30%, rgba(0,0,0,.05), rgba(0,0,0,.55) 70%, rgba(0,0,0,.78) 100%);
      pointer-events:none;
    }
    .grain{
      position:absolute;
      inset:0;
      opacity:.14;
      mix-blend-mode: overlay;
      pointer-events:none;
      background-image:
        repeating-linear-gradient(0deg, rgba(255,255,255,.08) 0px, rgba(255,255,255,0) 1px, rgba(255,255,255,0) 3px),
        repeating-linear-gradient(90deg, rgba(255,255,255,.06) 0px, rgba(255,255,255,0) 1px, rgba(255,255,255,0) 4px);
    }

    /* ai.com-like minimal layout */
    .topPill{
      position: fixed;
      top: 18px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 5;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(14px);
      font-family: var(--mono);
      font-size: 12px;
      letter-spacing: .2px;
      color: rgba(226,232,240,.90);
    }
    .topPill .mark{
      width: 18px;
      height: 18px;
      border-radius: 7px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 11px;
      color:#cbd5e1;
    }

    .stage{
      min-height: 100vh;
      position: relative;
      z-index: 2;
    }
    .line{
      position: absolute;
      left: 50%;
      max-width: 980px;
      width: min(980px, calc(100vw - 44px));
      text-align: center;
      font-size: clamp(26px, 3.1vw, 44px);
      line-height: 1.22;
      letter-spacing: -.01em;
      font-weight: 520;
      color: rgba(226,232,240,.92);
      text-wrap: balance;
      white-space: pre-wrap;
      will-change: transform, top, opacity;
    }
    .line1{
      top: 50%;
      transform: translate(-50%, -50%);
      transition: top .75s ease, transform .75s ease, opacity .25s ease;
    }
    .stage.stage2 .line1{
      top: 76px;
      transform: translate(-50%, 0) scale(0.78);
    }
    .line2{
      top: 58%;
      transform: translate(-50%, -50%);
      opacity: 0;
      transition: opacity .35s ease, top .65s ease, transform .65s ease;
    }
    .stage.stage2 .line2{
      opacity: 1;
      top: 61%;
    }
    /* after line2 finishes typing, settle slightly lower + smaller */
    .stage.stage3 .line2{
      opacity: 1;
      top: 74%;
      transform: translate(-50%, -50%) scale(0.92);
    }
    .caret{
      display:inline-block;
      width: 0.7ch;
      color: rgba(226,232,240,.85);
      animation: blink 1.05s steps(1, end) infinite;
    }
    .stage.stage2 #caret1{ opacity: 0; }
    @keyframes blink { 0%, 49% { opacity: 1; } 50%, 100% { opacity: 0; } }

    @media (max-width: 520px){
      .topPill{ font-size: 11px; padding: 9px 12px; }
      .line{ font-size: 24px; width: calc(100vw - 32px); }
      .stage.stage2 .line1{ top: 70px; transform: translate(-50%, 0) scale(0.82); }
    }
  </style>
</head>
<body>
  <div class="bg" aria-hidden="true">
    <canvas id="bg3d"></canvas>
    <div class="vignette"></div>
    <div class="grain"></div>
  </div>

  <div class="topPill" aria-label="Degla">
    <span class="mark">D</span>
    <span>Degla</span>
  </div>

  <main class="stage" id="stage" aria-label="Degla landing message">
    <div class="line line1" aria-live="polite">
      <span id="typed1"></span><span class="caret" id="caret1" aria-hidden="true">|</span>
    </div>
    <div class="line line2" aria-live="polite">
      <span id="typed2"></span><span class="caret" id="caret2" aria-hidden="true">|</span>
    </div>
  </main>

  <script src="./assets/vendor/three.min.js"></script>
  <script>
    const reduceMotion = window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    const bgCanvas = document.getElementById("bg3d");

    // 3D background (reuses the same feel as threed.php, but as a clean hero background)
    (function init3dBg(){
      if (reduceMotion) return;
      if (!window.THREE) return; // keep gradient background if Three isn't present
      const canvas = bgCanvas;

      let renderer;
      try {
        renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      } catch {
        return; // WebGL unavailable → keep gradient background
      }
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
      renderer.setClearColor(0x000000, 0);

      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x05070b, 120, 320);

      const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
      camera.position.set(0, 140, 150);
      camera.lookAt(0, 0, 10);

      const hemi = new THREE.HemisphereLight(0xdbeafe, 0x07140e, 0.55);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 0.85);
      dir.position.set(70, 120, 40);
      scene.add(dir);

      // Terrain texture (procedural)
      function makeTerrainTexture() {
        const c = document.createElement("canvas");
        c.width = 512; c.height = 512;
        const g = c.getContext("2d");
        g.fillStyle = "#0b2a18";
        g.fillRect(0,0,c.width,c.height);
        for (let i = 0; i < 11000; i++) {
          const x = Math.random() * c.width;
          const y = Math.random() * c.height;
          const a = Math.random() * 0.06;
          g.fillStyle = `rgba(255,255,255,${a})`;
          g.fillRect(x,y,1,1);
        }
        g.globalAlpha = 0.20;
        g.strokeStyle = "rgba(0,0,0,0.25)";
        for (let y = 0; y < c.height; y += 22) {
          g.beginPath();
          g.moveTo(0, y + (Math.sin(y/28) * 4));
          g.lineTo(c.width, y);
          g.stroke();
        }
        g.globalAlpha = 1;
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(1.5, 1.5);
        tex.anisotropy = 8;
        return tex;
      }

      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(260, 190, 1, 1),
        new THREE.MeshStandardMaterial({ map: makeTerrainTexture(), roughness: 1.0, metalness: 0.0, color: 0x0d3a22 })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      scene.add(ground);

      // Fields (simple)
      const FIELDS = {
        A: { x0: -110, x1: -40, z0: -55, z1: 5, color: 0x134a2a },
        B: { x0: -40, x1: 30, z0: -55, z1: 5, color: 0x14522e },
        C: { x0: 30, x1: 110, z0: -55, z1: 5, color: 0x154f2c },
        D: { xL: -40, xR: 110, zTop: 10, zBot: 70 }
      };
      function fieldMat(hex) {
        return new THREE.MeshStandardMaterial({ color: hex, roughness: 1.0, metalness: 0.0, transparent: true, opacity: 0.88 });
      }
      function addFieldRect(f) {
        const w = f.x1 - f.x0;
        const h = f.z1 - f.z0;
        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), fieldMat(f.color));
        mesh.rotation.x = -Math.PI/2;
        mesh.position.set((f.x0 + f.x1)/2, 0.03, (f.z0 + f.z1)/2);
        scene.add(mesh);
      }
      addFieldRect(FIELDS.A);
      addFieldRect(FIELDS.B);
      addFieldRect(FIELDS.C);
      // Triangle D
      {
        const f = FIELDS.D;
        const shape = new THREE.Shape();
        shape.moveTo(f.xL, f.zTop);
        shape.lineTo(f.xR, f.zTop);
        shape.lineTo(f.xL, f.zBot);
        shape.closePath();
        const tri = new THREE.Mesh(new THREE.ShapeGeometry(shape), fieldMat(0x124527));
        tri.rotation.x = -Math.PI/2;
        tri.position.y = 0.03;
        scene.add(tri);
      }

      // BASE marker
      const BASE = new THREE.Vector3(-120, 0.0, 78);
      {
        const ring = new THREE.Mesh(
          new THREE.RingGeometry(2.8, 4.2, 44),
          new THREE.MeshBasicMaterial({ color: 0x3b82f6, transparent:true, opacity: 0.50, side: THREE.DoubleSide })
        );
        ring.rotation.x = -Math.PI/2;
        ring.position.set(BASE.x, 0.08, BASE.z);
        scene.add(ring);
      }

      function makeDrone(colorHex) {
        const g = new THREE.Group();
        const body = new THREE.Mesh(
          new THREE.SphereGeometry(1.8, 18, 18),
          new THREE.MeshStandardMaterial({ color: colorHex, emissive: colorHex, emissiveIntensity: 0.22, roughness: 0.55 })
        );
        g.add(body);
        const armMat = new THREE.MeshStandardMaterial({ color: 0xe2e8f0, metalness: 0.2, roughness: 0.7 });
        const armGeo = new THREE.CylinderGeometry(0.12, 0.12, 6.0, 10);
        const arm1 = new THREE.Mesh(armGeo, armMat); arm1.rotation.z = Math.PI/2; g.add(arm1);
        const arm2 = new THREE.Mesh(armGeo, armMat); arm2.rotation.x = Math.PI/2; g.add(arm2);
        const glow = new THREE.PointLight(colorHex, 0.55, 26, 2);
        glow.position.set(0, 1.2, 0);
        g.add(glow);
        return g;
      }

      // Effects: minimal pulses (kept subtle)
      function makePulseRing(colorHex) {
        const geo = new THREE.RingGeometry(2.4, 3.2, 48);
        const mat = new THREE.MeshBasicMaterial({ color: colorHex, transparent:true, opacity: 0.0, side: THREE.DoubleSide, depthWrite:false });
        const ring = new THREE.Mesh(geo, mat);
        ring.rotation.x = -Math.PI/2;
        ring.position.y = -6.6;
        return ring;
      }

      const drone1 = makeDrone(0x3b82f6);
      const drone2 = makeDrone(0x22c55e);
      const drone3 = makeDrone(0xf59e0b);
      const drone4 = makeDrone(0x7c3aed);
      scene.add(drone1, drone2, drone3, drone4);

      const photoRing = makePulseRing(0xe2e8f0); drone2.add(photoRing);
      const scanRing  = makePulseRing(0xf59e0b); drone3.add(scanRing);
      const gridRing  = makePulseRing(0x7c3aed); drone4.add(gridRing);

      const ALT = 10;
      function v(x,y,z){ return new THREE.Vector3(x,y,z); }
      function genLawnmowerRect(f, rows=8) {
        const pts = [];
        const x0 = f.x0 + 6, x1 = f.x1 - 6;
        const z0 = f.z0 + 6, z1 = f.z1 - 6;
        for (let i=0;i<rows;i++){
          const t = rows===1?0:i/(rows-1);
          const z = z1 - t*(z1-z0);
          const lr = (i%2===0);
          pts.push(v(lr?x0:x1, ALT, z));
          pts.push(v(lr?x1:x0, ALT, z));
        }
        pts.push(v(pts[pts.length-1].x, ALT, z1));
        pts.push(v(pts[0].x, ALT, z1));
        pts.push(v(pts[0].x, ALT, pts[0].z));
        return pts;
      }
      function genPerimeterRect(f, rounds=2) {
        const pts = [];
        const x0 = f.x0 + 7, x1 = f.x1 - 7;
        const z0 = f.z0 + 7, z1 = f.z1 - 7;
        for (let r=0;r<rounds;r++){
          pts.push(v(x0, ALT, z1));
          pts.push(v(x0, ALT, z0));
          pts.push(v(x1, ALT, z0));
          pts.push(v(x1, ALT, z1));
          pts.push(v(x0, ALT, z1));
        }
        return pts;
      }
      function genCircleCenters(f) {
        const x0 = f.x0 + 10, x1 = f.x1 - 10;
        const z0 = f.z0 + 10, z1 = f.z1 - 10;
        return [
          v(x0 + (x1-x0)*0.30, ALT, z0 + (z1-z0)*0.30),
          v(x0 + (x1-x0)*0.72, ALT, z0 + (z1-z0)*0.52),
          v(x0 + (x1-x0)*0.45, ALT, z0 + (z1-z0)*0.74),
        ];
      }
      function genCircleLoops(centers, radius=9, segments=28) {
        const pts = [];
        for (const c of centers) {
          for (let i=0;i<=segments;i++){
            const a = (i/segments) * Math.PI*2;
            pts.push(v(c.x + Math.cos(a)*radius, ALT, c.z + Math.sin(a)*radius));
          }
        }
        pts.push(pts[0].clone());
        return pts;
      }
      function genTriSweep(tri, rows=9) {
        const pts = [];
        const xL = tri.xL + 6;
        const xR = tri.xR - 6;
        const zT = tri.zTop + 6;
        const zB = tri.zBot - 6;
        for (let i=0;i<rows;i++){
          const t = rows===1?0:i/(rows-1);
          const z = zB - t*(zB-zT);
          const frac = (tri.zBot - z) / Math.max(1, (tri.zBot - tri.zTop));
          const xDiag = tri.xL + frac*(tri.xR - tri.xL);
          const xMax = Math.min(xR, xDiag - 6);
          const lr = (i%2===0);
          pts.push(v(lr?xL:xMax, ALT, z));
          pts.push(v(lr?xMax:xL, ALT, z));
        }
        pts.push(v(xL, ALT, zB));
        pts.push(pts[0].clone());
        return pts;
      }
      function genTransit(from, to, laneZ) {
        const zLane = THREE.MathUtils.clamp(laneZ, -90, 90);
        const dx = to.x - from.x;
        const s = Math.sign(dx || 1);
        const x1 = THREE.MathUtils.clamp(from.x + s*18, -130, 130);
        const x2 = THREE.MathUtils.clamp(to.x - s*18, -130, 130);
        return [ v(from.x, ALT, from.z), v(x1, ALT, zLane), v(x2, ALT, zLane), v(to.x, ALT, to.z) ];
      }

      const core1 = genTriSweep({ xL: FIELDS.D.xL, xR: FIELDS.D.xR, zTop: FIELDS.D.zTop, zBot: FIELDS.D.zBot }, 10);
      const core2 = genCircleLoops(genCircleCenters(FIELDS.C), 9, 28);
      const core3 = genPerimeterRect(FIELDS.B, 3);
      const core4 = genLawnmowerRect(FIELDS.A, 9);

      const entry1 = core1[0], entry2 = core2[0], entry3 = core3[0], entry4 = core4[0];
      const t1 = genTransit(BASE, entry1, 55);
      const t2 = genTransit(BASE, entry2, 40);
      const t3 = genTransit(BASE, entry3, 25);
      const t4 = genTransit(BASE, entry4, 10);

      const curves = {
        d1: { transit: new THREE.CatmullRomCurve3(t1, false, "catmullrom", 0.0), core: new THREE.CatmullRomCurve3(core1, true, "catmullrom", 0.0) },
        d2: { transit: new THREE.CatmullRomCurve3(t2, false, "catmullrom", 0.0), core: new THREE.CatmullRomCurve3(core2, true, "catmullrom", 0.0) },
        d3: { transit: new THREE.CatmullRomCurve3(t3, false, "catmullrom", 0.0), core: new THREE.CatmullRomCurve3(core3, true, "catmullrom", 0.0) },
        d4: { transit: new THREE.CatmullRomCurve3(t4, false, "catmullrom", 0.0), core: new THREE.CatmullRomCurve3(core4, true, "catmullrom", 0.0) },
      };

      const clock = new THREE.Clock();

      function setSize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        renderer.setSize(w, h, false);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      }
      window.addEventListener("resize", setSize);
      setSize();

      function placeAlong(obj, curve, u, heightJitter=0.0) {
        const p = curve.getPointAt(u);
        const t = curve.getTangentAt(u);
        obj.position.copy(p);
        obj.position.y = ALT + heightJitter;
        const yaw = Math.atan2(t.x, t.z);
        obj.rotation.set(0, yaw, 0);
      }

      function distanceAlongWithStops(tSec, speed, moveLen, stopCount, dwellSec) {
        const moveTime = moveLen / speed;
        const cycleTime = moveTime + stopCount * dwellSec;
        let t = ((tSec % cycleTime) + cycleTime) % cycleTime;
        for (let i = 0; i <= stopCount; i++) {
          const nextD = (i === stopCount) ? moveLen : (i / stopCount) * moveLen;
          const prevD = (i === 0) ? 0 : ((i - 1) / stopCount) * moveLen;
          const segD = nextD - prevD;
          const segT = segD / speed;
          if (t < segT) return { dist: prevD + t * speed, paused: false };
          t -= segT;
          if (i < stopCount) {
            if (t < dwellSec) return { dist: nextD, paused: true };
            t -= dwellSec;
          }
        }
        return { dist: 0, paused: false };
      }

      function tick() {
        const t = clock.elapsedTime;
        const takeoffSec = 1.0;
        const takeoff = Math.min(1, t / takeoffSec);
        const lift = 1.0 + (ALT - 1.0) * (1 - Math.pow(1 - takeoff, 3));

        // Drone 1
        {
          const transitDur = 2.2;
          if (t < transitDur) { placeAlong(drone1, curves.d1.transit, t / transitDur, 0.4*Math.sin(t*4)); drone1.position.y = lift; }
          else { placeAlong(drone1, curves.d1.core, ((t - transitDur) * 0.030) % 1, 0.25*Math.sin(t*3.3)); }
        }
        // Drone 2 (photos)
        {
          const transitDur = 2.4;
          const speed = 22;
          if (t < transitDur) { placeAlong(drone2, curves.d2.transit, t / transitDur, 0.35*Math.sin(t*4.2)); drone2.position.y = lift; photoRing.material.opacity = 0; }
          else {
            const len = curves.d2.core.getLength();
            const out = distanceAlongWithStops(t - transitDur, speed, len, 3, 0.85);
            const u = THREE.MathUtils.clamp(out.dist / len, 0, 1);
            placeAlong(drone2, curves.d2.core, u, 0.25*Math.sin(t*4.0));
            if (out.paused) {
              const k = (Math.sin(t * 9.0) * 0.5 + 0.5);
              photoRing.scale.setScalar(0.9 + k * 2.2);
              photoRing.material.opacity = 0.14 + k * 0.10;
            } else {
              photoRing.material.opacity = 0.0;
            }
          }
        }
        // Drone 3
        {
          const transitDur = 2.1;
          if (t < transitDur) { placeAlong(drone3, curves.d3.transit, t / transitDur, 0.35*Math.sin(t*3.8)); drone3.position.y = lift; }
          else { placeAlong(drone3, curves.d3.core, ((t - transitDur) * 0.024) % 1, 0.20*Math.sin(t*3.0)); }
          const k = (Math.sin(t*2.2) * 0.5 + 0.5);
          scanRing.scale.setScalar(0.8 + k*3.0);
          scanRing.material.opacity = 0.04 + k * 0.08;
        }
        // Drone 4
        {
          const transitDur = 2.0;
          if (t < transitDur) { placeAlong(drone4, curves.d4.transit, t / transitDur, 0.35*Math.sin(t*3.9)); drone4.position.y = lift; }
          else { placeAlong(drone4, curves.d4.core, ((t - transitDur) * 0.028) % 1, 0.20*Math.sin(t*3.2)); }
          const k = (Math.sin(t*1.8) * 0.5 + 0.5);
          gridRing.scale.setScalar(0.9 + k*2.6);
          gridRing.material.opacity = 0.03 + k * 0.06;
        }

        renderer.render(scene, camera);
        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    })();

    // typewriter (two-stage, with layout shift)
    const stageEl = document.getElementById("stage");
    const typed1 = document.getElementById("typed1");
    const typed2 = document.getElementById("typed2");
    const line1 = "Degla is the Cursor for mission planning.";
    const line2 = "Vibe‑plan a full mission in natual language and watch a swarm of drones coordinate through constraints and failures to achieve your goal.";

    function setText(el, text) {
      if (!el) return;
      el.textContent = text;
    }

    function typeLine(el, line, speedBase, speedJitter, punctPause, done) {
      let i = 0;
      function step() {
        setText(el, line.slice(0, i));
        if (i >= line.length) return done && done();
        const ch = line[i] || "";
        i++;
        const isPunct = ch === "." || ch === "—" || ch === ",";
        const delay = speedBase + (Math.random() * speedJitter) + (isPunct ? punctPause : 0);
        window.setTimeout(step, delay);
      }
      step();
    }

    if (reduceMotion) {
      stageEl && stageEl.classList.add("stage2");
      setText(typed1, line1);
      setText(typed2, line2);
    } else {
      window.setTimeout(() => {
        // Stage 1: type line 1 centered
        typeLine(typed1, line1, 22, 26, 140, () => {
          // Shift line 1 upward under the Degla pill
          window.setTimeout(() => {
            stageEl && stageEl.classList.add("stage2");
            // Stage 2: type line 2 slightly slower, slightly lower
            window.setTimeout(() => {
              typeLine(typed2, line2, 22, 26, 140, () => {
                // once typed, subtly settle lower/smaller
                window.setTimeout(() => stageEl && stageEl.classList.add("stage3"), 220);
              });
            }, 220);
          }, 220);
        });
      }, 180);
    }
  </script>
</body>
</html>

